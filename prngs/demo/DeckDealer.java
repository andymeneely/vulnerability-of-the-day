import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Random;

/**
 * This is a basic simulation of a class that builds a deck of cards, and shuffles them.
 * 
 * The vulnerability that this demonstrates is basing your random number seeds on System.currentTimeMillis().
 * If attackers know roughly the time that you had to reset your seed, then they can reverse-engineer your
 * randomness - even if your random number generator is using SecureRandom.
 * @author Andy Meneely
 * 
 */
public class DeckDealer {
	private static final String[] card = { "A", "2", "3", "4", "5", "6", "7", "8", "9", "T", "J", "Q", "K" };
	private static final String[] suit = { "C", "D", "H", "S" };

	public static void main(String[] args) {
		DeckDealer deckDealer = new DeckDealer();
		System.out.println("Shuffle 1: " + deckDealer.nextShuffle());
		System.out.println("Shuffle 2: " + deckDealer.nextShuffle());
	}

	private Random random;
	private List<Integer> deck = initDeck();

	public DeckDealer() {
		random = new Random(System.currentTimeMillis());
		// This can be cracked even when using System.nanoTime(), although it's a bit harder
		// random = new Random(System.nanoTime());
	}

	public DeckDealer(long seed) {
		random = new Random(seed);
		deck = initDeck();
	}

	public String nextShuffle() {
		String str = "";
		int numShuffles = 2;
		for (int i = 0; i < numShuffles; i++) {
			Collections.shuffle(deck, random);
			for (int cardI = 0; cardI < 52; cardI++) {
				str += fromIndex(deck.get(cardI)) + " ";
			}
		}
		return str;
	}

	private static String fromIndex(Integer cardIndex) {
		return card[cardIndex % card.length] + suit[cardIndex / card.length];
	}

	private static List<Integer> initDeck() {
		List<Integer> deck = new ArrayList<Integer>();
		for (int i = 0; i < 52; i++)
			deck.add(i);
		return deck;
	}

}
